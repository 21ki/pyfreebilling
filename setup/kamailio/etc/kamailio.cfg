PyFB v3.0 - file version : 2019-01-08 19:08:14

#-------------
#-------------
## 0_init.cfg

#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.2 - PyFreeBilling v3.0
# config file : v3.0
#
#-- AGPL License

#-------------

#-------------
#-------------
## 1_vars.cfg

#----------------------- Custom Defined Variables ----------------------------#
#-------------------------------------

#-- IP addresses settings

#!substdef "!MY_IP_ADDRESS!1.1.1.1!g"
#!substdef "!MY_IP_ADDRESS_INTERNAL!1.1.1.2!g"
#!substdef "!MY_IP_ADDRESS_EXTERNAL!1.1.1.3!g"

#-- Domain settings

#!substdef "!SIP_FROM_DOMAIN_NAT!sip:pinger@pyfb.org!g"
#!substdef "!SIP_DOMAIN_KEEPALIVE!sip:keepalive@pyfb.org!g"

#-- DB settings

# IMPORTANT : MUST BE PRESENT IN kamailio-local.cfg !

##!define DBURL "postgres://kamailiopyfb:password@127.0.0.1:5432/kamailiopyfb"

#-- Timer settings
#!substdef "!TIMER_INVITE_NOANSWER!10000!g"

#------------- SECURITY  ----------------------------------#

#!define UABLOCKED "friendly-scanner|sipcli|sundayddr" ## L594
#!define IPBANEXPIRE 300 ## L403
##check pike param

##!define WITH_TLS


#------------- SIPCAPTURE  --------------------------------#

#!define SIPCAPTURL "sip:1.1.1.4:9060"
#!define SIPCAPT 0

#------------- Global Parameters --------------------------#

async_workers=8

#!define MULTIDOMAIN 0

#-- SIP HEADERS

server_signature = no
server_header = "Server: PyFB_v3"
user_agent_header = "X-PROXY: PyFB_v3"
sip_warning = 0


#------------ Others settings ------------------------------#
fork=yes
children=8
tcp_connection_lifetime=3605
tcp_accept_no_cl=yes
disable_tcp=no
enable_tls=false
tos=0x68

#------------- DNS settings -------------------------------#
use_dns_cache=on
dns_try_ipv6=no
dns_retr_time=1
dns_retr_no=3
dns_use_search_list=yes

#------------- Local settings -------------------------------#
include_file "kamailio-local.cfg"

#-------------

#-------------
#-------------
## 2_logging.cfg

#!ifdef WITH_DEBUG
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=4
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!else
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=2
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!endif

#-- syslog facility
log_facility=LOG_LOCAL0
log_name="kamailio"

#-------------

#-------------
#-------------
## 3_flags.cfg

#------------- FLAGS  -------------------------------------#

 #!define FLT_ACC 1
 #!define FLT_ACCMISSED 2
 #!define FLT_ACCFAILED 3
 #!define FLT_NATS 5
 #!define FLB_NATB 6
 #!define FLB_NATSIPPING 7
 #!define SIP_IP_OK 8
 #!define RINGING 10
 #!define CUST_AUTH_OK 11
 #!define RTPE 13
 #!define CANCELLED 14
 #!define ANSWERED 17

 #!define TRUSTED_ADR_GR_CUST 1
 # http://kamailio.org/docs/modules/4.4.x/modules/permissions.html#sec-registration-permissions
 #!define TRUSTED_ADR_GR_REG_CUST 2 # filtered to be implemented
 #!define TRUSTED_ADR_GR_GW 10
 #!define GROUP_GL_NORM_RULE 0

 #!define GROUP_OP_SERVERS 4

 flags
   FLAG_FROM_CUST: 10,
   FLAG_FROM_PROV: 11,
   FLAG_TRUSTED_SOURCE: 12,

#-------------

#-------------
#-------------
## 4_modules.cfg

#-------------------- Modules Section ----------------------------------------#

#-- modules directory

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#-- core modules

loadmodule "kex.so"
loadmodule "corex.so"

#-------- Loading Mod postgres ------------------------------------------------#

loadmodule "db_postgres.so"

#-------- Loading Mod TLS -----------------------------------------------------#

#!ifdef WITH_TLS
  enable_tls=yes
  loadmodule "tls.so"
  modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#-------- Loading Mod TM ------------------------------------------------------#

loadmodule "tm.so"
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", TIMER_INVITE_NOANSWER)
modparam("tm", "fr_inv_timer", 120000)

loadmodule "tmx.so"

#-------- Loading Mod SL ---------------------------------------------#

loadmodule "sl.so"

#-------- Loading Mod RR ---------------------------------------------#

loadmodule "rr.so"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_full_lr", 1)

#-------- Loading Mod PV ---------------------------------------------#
loadmodule "pv.so"
modparam("pv", "varset", "defaultChannels=i:2")
modparam("pv", "varset", "max_attempts=i:2")

#-------- Loading Mod AVPOPS -----------------------------------------#
loadmodule "avpops.so"
modparam("avpops", "db_url", DBURL)
modparam("avpops", "avp_table", "usr_preferences")

#-------- Loading Mod MAXFWD -----------------------------------------#
loadmodule "maxfwd.so"

#-------- Loading Mod USRLOC -----------------------------------------#
loadmodule "usrloc.so"
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "timer_interval", 20)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)

#-------- Loading Mod ALIASDB ----------------------------------------#
loadmodule "alias_db.so"
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)

#-------- Loading Mod REGISTRAR --------------------------------------#
## usrloc and sl module must be loaded before
loadmodule "registrar.so"
modparam("registrar", "method_filtering", 1)
modparam("registrar", "append_branches", 0)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod AUTH -----------------------------------------#
loadmodule "auth.so"
modparam("auth", "nonce_count", 1)
modparam("auth", "qop", "auth")
modparam("auth", "nonce_expire", 60)
modparam("auth", "nonce_auth_max_drift", 2)
modparam("auth", "auth_checks_register", 11)
modparam("auth", "auth_checks_no_dlg", 9)
modparam("auth", "auth_checks_in_dlg", 15)
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "version_table", 0)
loadmodule "permissions.so"
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(s:sipacid)")

#-------- Loading Mod DISPATCHER ------------------------------------#
loadmodule "dispatcher.so"
#modparam("dispatcher", "db_url", DBPYFBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 1)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_latency_estimator_alpha", 900)
modparam("dispatcher", "ds_ping_from", "sip:sipcheck@MY_IP_ADDRESS")
modparam("dispatcher", "ds_ping_method", "INFO")
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_probing_threshold", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=5;class=2;code=480;code=404;code=403;code=488;class=3")

#-------- Loading Mod DIALPLAN ---------------------------------------#
loadmodule "dialplan.so"
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "attrs_pvar", "$avp(s:dest)")

#-------- Loading Mod JSONRPCS CTL RPC ------------------------------#
loadmodule "jsonrpcs.so"
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")
loadmodule "ctl.so"
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl") #kamcmd
loadmodule "cfg_rpc.so"

#-------- Loading Mod DIALOG ---------------------------------------#
/* loadmodule "dialog.so"
modparam("dialog", "db_url", DBURL)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_update_period", 45)
modparam("dialog", "profiles_with_value", "endptChannels;custChannels;didChannels;")
modparam("dialog", "dlg_flag", 4) */

#-------- Loading Mod NATHELPER ------------------------------------#
## usrloc module must be loaded before
loadmodule "nathelper.so"
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "SIP_FROM_DOMAIN_NAT")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod RTPENGINE  ------------------------------------#
loadmodule "rtpengine.so"
modparam("rtpengine", "rtpengine_sock", RTPENGINE_LIST)

#-------- Loading Mod IPOPS -----------------------------------------#
loadmodule "ipops.so"

#-------- Loading Mod UAC -------------------------------------------#
## tm, rr et dialog modules must be loaded before
loadmodule "uac.so"
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_retry_interval", 300)
modparam("uac", "reg_contact_addr", "MY_IP_ADDRESS_EXTERNAL:5060")

#-------- Loading Mod REDIS -----------------------------------------#
#loadmodule "ndb_redis.so"
#modparam("ndb_redis", "server", REDIS)

#-------- Loading Mod PIKE ------------------------------------------#
#!ifdef WITH_ANTIFLOOD
  loadmodule "pike.so"
  modparam("pike", "sampling_time_unit", 2)
  modparam("pike", "reqs_density_per_unit", 16)
  modparam("pike", "remove_latency", 4)
#!endif

#-------- Loading Mod XLOG XHTTP SIPUTILS AND SANITY  ---------------#
loadmodule "textops.so"
loadmodule "sdpops.so"
## sl module must be loaded before
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"

#-------- Loading Mod DEBUG -----------------------------------------#
#!ifdef WITH_DEBUG
  loadmodule "debugger.so"
  modparam("debugger", "cfgtrace", 1)
  modparam("debugger", "log_level_name", "exec")
#!endif

#-------- Loading Mod HASH TABLE -------------------------------------#
loadmodule "htable.so"
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

#------ Loading Mod ACC ----------------------------------------------#

loadmodule "acc.so"
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "cdr_enable", 0)
modparam("acc", "db_url", DBURL)
modparam("acc", "cdrs_table", "cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "db_table_missed_calls", "failed_sessions")
modparam("acc", "time_mode", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
#modparam("acc", "cdr_extra","attempt=$dlg_var(call_attempts);src_ip=$dlg_var(src_ip);calling_num=$dlg_var(caller_id);called_number=$dlg_var(called_number);sipCode=$dlg_var(sip_code);sipReason=$dlg_var(sip_reason)")
#modparam("acc", "db_extra","attempt=$dlg_var(call_attempts);src_ip=$dlg_var(src_ip);calling_num=$dlg_var(caller_id);called_number=$dlg_var(called_number);sipCode=$dlg_var(sip_code);sipReason=$dlg_var(sip_reason)")

#------ Loading Mod SIPTRACE -------------------------------------------#
#!ifdef WITH_SIPTRACE
    loadmodule "siptrace.so"
    modparam("siptrace", "duplicate_uri", SIPCAPTURL)
    modparam("siptrace", "hep_mode_on", 1)
    modparam("siptrace", "trace_to_database", 0)
    modparam("siptrace", "trace_flag", 2)
    modparam("siptrace", "hep_version", 1)
    modparam("siptrace", "trace_on", SIPCAPT)
#!endif

#-------------

#-------------
#-------------
## 5_request_route.cfg

#-- MAIN ROUTING SECTION
# -1- request route
# -2- req init
# -3- within dialog
# -4- relay
# -5- uri update for dialog request
# -6- manage branch
# -7- manage reply
# -8- manage failure
# -9- optionnaly block 3XX

request_route {

    # log the basic info regarding this call
    xlog("L_INFO", "$ci|start|\n");
    xlog("L_INFO", "$ci|log|===================================================\n");
    xlog("L_INFO", "$ci|log| New SIP message $rm with call-ID $ci \n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");
    xlog("L_INFO", "$ci|log| received $pr request $rm $ou\n");
    xlog("L_INFO", "$ci|log| source $si:$sp\n");
    xlog("L_INFO", "$ci|log| from $fu\n");
    xlog("L_INFO", "$ci|log| to $tu\n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");

    # siptrace
    #!ifdef WITH_SIPTRACE
      sip_trace();
      setflag(22);
    #!endif

    # per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # OPTION processing
    if(is_method("OPTIONS") && uri==myself) {
        sl_send_reply("200","Keepalive");
        xlog("L_INFO", "$ci|log| Send SIP answer 200-OK - Keepalive\n");
        xlog("L_INFO", "$ci|stop|=================================================\n");
        exit;
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle retransmissions
    if(t_precheck_trans()) {
        t_check_trans();
        exit;
    }
    t_check_trans();

    # authentication
    route(AUTH);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
    }

    # handle presence related requests
    route(PRESENCE);

    # handle registrations
    #!ifdef WITH_REGISTRAR
      if (is_method("REGISTER")) {
          route(REGISTRAR);
      }
    #!endif

    if ($rU==$null) {
        # request with no Username in RURI
        xlog("L_INFO", "$ci|stop|-------SIP 484---------------\n");
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # save callee ID
    $avp(callee) = $rU;
    route(DISPATCH);

    route(RELAY);
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "$ci|log|--MANAGE_BRANCH--\n");
    xlog("L_INFO", "$ci|log|--new branch [$T_branch_idx] to $ru--\n");
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "$ci|log|--MANAGE_REPLY--\n");
    xlog("L_INFO", "$ci|log|--Handling SIP response--\n");
    xdbg("incoming reply\n");

    if(status=~"18[03]") {
        xlog("L_INFO", "$ci|log|--ringing or session in progress--\n");
    }
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }

  #!ifdef WITH_SIPTRACE
    sip_trace();
  #!endif
    if(nat_uac_test("18")) {
        #force_rport();
        #set_contact_alias();
        if (sdp_content()) {
            if(isflagset(FLAG_FROM_CUST)){
                xlog("L_INFO", "$ci|log|-- status [12]xxi from C5 - engage rtpengine--\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
            } else {
                xlog("L_INFO", "$ci|log|-- status [12]xx from outside - engage rtpengine--\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
            }
        }
    }
}


# Manage failure replies
failure_route[MANAGE_FAILURE] {
    xlog("L_INFO", "$ci|log|--MANAGE_FAILURE--\n");
    route(NATMANAGE);

    if (t_is_canceled()) exit;

  #!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
  #!endif
}

#-------------

#-------------
#-------------
## 6_relay.cfg

# Wrapper for relaying requests
route[RELAY] {

    xlog("L_INFO", "$ci|log|--RELAY--\n");
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }

    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(sdp_content()) {
            if(isflagset(FLAG_FROM_CUST)){
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
            }
        }
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }

    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        xlog("L_INFO", "$ci|end|unable to relay message\n");
        sl_reply_error();
    } else {
        xlog("L_INFO", "$ci|pass|successfull relay $du\n");
    }

    xlog("L_INFO", "$ci|stop|----------------------------\n");
    exit;
}

#-------------

#-------------
#-------------
## 7_reqinit.cfg

# Per SIP request initial checks
route[REQINIT] {
    xlog("L_INFO", "$ci|log|--REQINIT--\n");

  #!ifdef WITH_ANTIFLOOD
    xlog("L_INFO", "$ci|log|Antiflood protection\n");
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }

        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    if($ua =~ "friendly-scanner|sipcli|sundayddr") {
        xlog("L_WARN", "$ci|end|dropping message with user-agent $ua from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    xlog("L_INFO", "$ci|log|OK -> continue\n");
  #!endif

    if (is_method("INVITE|REGISTER")) {
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_WARN", "$ci|end|Someone from $si is doing an sql injection attack, blocking!\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    # initial sanity checks -- messages with
    # max_forwards==0, or excessively long requests
    if (!maxfwd_process("50") && $retcode==-1) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    # next hop is a gateway, so make no sense to
    # forward if MF is 0 (after decrement)
    if ( is_maxfwd_lt("5") ) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    /*if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }*/

    if(!sanity_check("1511", "7")) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    # CVE-2018-8828
    if($(ci{s.len}) + $(hdr(CSeq){s.len}) + $(ft{s.len}) + $(sel(v.branch){s.len}) >= 254) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp - header >=254\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }
    if($(rU{s.len}) > 32) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp - r-URI username > 32\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }
}

#-------------

#-------------
#-------------
## 8_withindlg.cfg

# Handle requests within SIP dialogs
route[WITHINDLG] {
    xlog("L_INFO", "$ci|log|--WITHINDLG--\n");

    if (!has_totag()) {
        xlog("L_INFO", "$ci|log| return\n");
        return;
    }

    if (is_method("REGISTER")) {
        xlog("L_INFO", "$ci|log| REGISTER method - return\n");
        return;
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        xlog("L_INFO", "$ci|log|loose route TRUE\n");
        route(DLGURI);

        if(is_method("INVITE|UPDATE") && sdp_content() && nat_uac_test("18")) {
            if (has_body("application/sdp")) {
                if(isflagset(FLAG_FROM_CUST)){
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
                } else {
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
                }
            }
        }

        if (is_method("BYE")) {
            xlog("L_INFO", "$ci|log|Method BYE - set acc flag\n");
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            xlog("L_INFO", "$ci|log|Method ACK\n");
            route(NATMANAGE);
        } else if ( is_method("INVITE|NOTIFY") ) {
            xlog("L_INFO", "$ci|log|Method INVITE|NOTIFY\n");
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }

        xlog("L_INFO", "$ci|log|Message has tag - no loose route -> relay\n");
        route(RELAY);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    if ( is_method("INVITE") ) {
        sl_send_reply("100","Your Re-INVITE is received");


        if (!t_relay()) {
            sl_reply_error();
            break;
        }

        # sl_send_reply("200","OK");
        exit;
    }


    xlog("L_INFO", "$ci|stop|----------------------------\n");
    sl_send_reply("404","Not here");
    exit;
}

#-------------

#-------------
#-------------
## 9_dlguri.cfg

# URI update for dialog requests
route[DLGURI] {
    xlog("L_INFO", "$ci|log|--DLGURI--\n");

    if(!isdsturiset()) {
        xlog("L_INFO", "$ci|log|--destination address URI (outbound proxy address) not set--\n");
        handle_ruri_alias();
        switch ($rc) {
        case -1:
            xlog("L_ERR", "$ci|log|--Failed to handle alias of R-URI $ru--\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            xlog("L_INFO", "$ci|log|--Alias param was found - Routing in-dialog $rm from $fu to $du--\n");
            break;
        case 2:
            xlog("L_INFO", "$ci|log|--Alias param was not found and nothing was done - Routing in-dialog $rm from $fu to $ru--\n");
            break;
        };
    }

    xlog("L_INFO", "$ci|log| return \n");
    return;
}

#-------------

#-------------
#-------------
## 10_registrar.cfg

# Handle SIP registrations
route[REGISTRAR] {
    xlog("L_INFO", "$ci|log|--REGISTRAR--\n");
    if (!is_method("REGISTER")) {
        xlog("L_INFO", "$ci|log|Not a REGISTER method\n");
        xlog("L_INFO", "$ci|log| return\n");
        return;
    }

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        #!ifdef WITH_NATSIPPING
           # do SIP NAT pinging
           setbflag(FLB_NATSIPPING);
        #!endif
    }

    xlog("L_INFO", "$ci|log|Save user in location DB\n");
    if (!save("location")) {
        sl_reply_error();
    }

    xlog("L_INFO", "$ci|stop|----------------------------\n");
    exit;
}

event_route[usrloc:contact-expired] {
  xlog("L_INFO", "expired contact for $ulc(exp=>aor)\n");
}

#-------------

#-------------
#-------------
## 11_location.cfg

# User location service
route[LOCATION] {
xlog("L_INFO", "$ci|log|--LOCATION--\n");
$var(DID) = $rU;

    # search in DB-based aliases
    xlog("L_INFO", "$ci|log|Check if DestNum is DID list \n");
    if(alias_db_lookup("dbaliases")) {
        xlog("L_INFO", "$ci|log|DID found in dbaliases.  R-URI=$ru\n");
        $avp(s:dest)="DID";
        append_hf("P-hint: DID routing\r\n");
    }
    else  {
        xlog("L_INFO", "$ci|log|R-URI=$ru  DID Not found in dbaliases\n");
        return;
    }
    xlog("L_INFO", "$ci|log|Check if corresponding user is registred\n");
    if (!lookup("location")) {
        $var(rc) = $rc;
        #route(TOVOICEMAIL);
        t_newtran();
        switch ($var(rc)) {
        case -1:
            xlog("L_INFO","$ci|log|R-URI=$ru - no contact found in location DB - continue \n");
            send_reply("480", "Temporarily Unavailable");
        case -3:
            xlog("L_INFO","$ci|log|R-URI=$ru - internal error when searching in location DB - 404 \n");
            send_reply("404", "Not Found");
            exit;
        case -2:
            xlog("L_INFO","$ci|log|R-URI=$ru - contacts found, but method not support in location DB - 405 \n");
            send_reply("405", "Method Not Allowed");
            exit;
        }
    } else {
    # User is registered. Overwrite the username part of the R-URI with the DID
    $rU = $var(DID);

    if($hdr(X-PyFB-CallType) == "DIDIN" || $hdr(X-PyFB-CallType) == "DIDOUT") {
        # Numbers normalization
        $var(sipaccount) = $hdr(X-PyFB-SIPAccountId);
        xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
        # Callee normalization
        if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcalleein)")) {
          xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcalleein)\n");
          xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
          if (!dp_translate("$avp(s:grpnormcalleein)", "$rU/$rU")) {
            xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
          }
          else {
            # To field is not auto updated - do it now
            uac_replace_to("sip:$rU@$rd");
          }

          xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
        } else {
          xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
        }

        # Caller normalization
        if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallerin)")) {
          xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcallerin)\n");
          xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
          if (!dp_translate("$avp(s:grpnormcallerin)", "$fU/$avp(s:callernum)")) {
              xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
          } else {
              uac_replace_from("$avp(s:callernum)", "sip:$avp(s:callernum)@$fd");
              remove_hf("P-Asserted-Identity");
              append_hf("P-Asserted-Identity: <sip:$avp(s:callernum)@$fd>\r\n");
          }
          xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
        } else {
          xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
        }
    }

    append_hf("X-PyFB-DestDIDNum: $var(DID)\r\n");
    xlog("L_INFO","$ci|log|R-URI=$ru  Location=$du - contact found in location DB - route to user \n");
    xlog("L_INFO","$ci|log| return \n");
    return;
  }

        # when routing via usrloc, log the missed calls also
        if (is_method("INVITE")) {
            setflag(FLT_ACCFAILED); # -- this is added to record failed calls
            setflag(FLT_ACCMISSED);
        }

  # via FS
  #route(RELAY);
        #exit;
}

#-------------

#-------------
#-------------
## 12_presence.cfg

# Presence server processing
route[PRESENCE] {
        xlog("L_INFO", "$ci|log|--PRESENCE--\n");
        if(!is_method("PUBLISH|SUBSCRIBE")) return;
        xlog("L_INFO", "$ci|log| Event: $hdr(Event)\n");

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                # returns here if no voicemail server is configured
                xlog("L_INFO", "$ci|stop| 404 - No voicemail service\n");
                sl_send_reply("404", "No voicemail service");
                exit;
        }

#!ifdef WITH_PRESENCE
        if (!t_newtran()) {
                sl_reply_error();
                exit;
        }

        if(is_method("PUBLISH")) {
                handle_publish();
                t_release();
        } else if(is_method("SUBSCRIBE")) {
                handle_subscribe();
                t_release();
        }
        exit;
#!endif

        # if presence enabled, this part will not be executed
        if(is_method("SUBSCRIBE") && $hdr(Event)=="presence.winfo") {
                xlog("L_INFO", "$ci|stop| 489 - No presence service\n");
                sl_send_reply("489", "No presence service");
                exit;
        }

        if (is_method("PUBLISH") || $rU==$null) {
                xlog("L_INFO", "$ci|stop| 404 - Not here\n");
                sl_send_reply("404", "Not here");
                exit;
        }
        xlog("L_INFO", "$ci|log| return \n");
        return;
}

#-------------

#-------------
#-------------
## 14_auth.cfg

# Authorization and authentication
# First determine the origini of the call based on IP address :
# 1- from customer
# 2- from provider IP Auth
# 3- From provider - regsitred gateway
# 4- from customer et REGISTER message
#
# The second step is to determine is the sip user is registred (Not for the POC)
route[AUTH] {
  xlog("L_INFO", "$ci|log|--AUTH-\n");
  xlog("L_INFO", "$ci|log| Starting auth process ...\n");

  # 1- message fom customer
  xlog("L_INFO", "$ci|log|IP Auth process ...\n");
  if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_CUST)) {
    setflag(FLAG_FROM_CUST);
    $var(sipaccount) = $avp(s:sipacid);
    append_hf("X-PyFB-AccountId: $avp(s:sipacid)\r\n");
    xlog("L_INFO", "$ci|log|Call from customer : Source IP allowed - sipaccount : $avp(s:sipacid)\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 2- message from provider
  if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_GW)) {
    setflag(FLAG_FROM_PROV);
    xlog("L_INFO", "$ci|log|Call from provider GW : Source IP allowed\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 3- message from a registred gateway
### A TERMINER
  if((!is_method("REGISTER")) && uac_reg_lookup("$rU", "$ru")) {
    setflag(FLAG_FROM_PROV);
    xlog("L_INFO", "$ci|log| request from a remote SIP provider [$rU => $tU]\n");
    ## si URI not DID : $tU in $rU
    $rU = $tU;
    xlog("L_INFO", "$ci|log| request from a remote SIP provider [$rU => $tU]\n");
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 4- check credential auth
  if (is_method("REGISTER") || uri==myself) {
    # authenticate requests
    if (!auth_check("$fd", "subscriber", "3")) {
      switch ($retcode) {
        case -1:
          xlog("L_WARN", "$ci|log|auth failed - code -1 generic error - src ip: $si\n");
          t_reply("403", "Forbidden");
          exit;
        case -2:
          xlog("L_WARN", "$ci|log|auth failed - code -2 invalid password - src ip: $si\n");
          t_reply("500", "Internal Server Error");
          exit;
        case -3:
          xlog("L_WARN", "$ci|log|auth failed - code -3 invalid user - src ip: $si\n");
          t_reply("400", "Bad Request");
          exit;
        case -4:
          xlog("L_WARN", "$ci|log|auth failed - code -4 nonce exprired - src ip: $si\n");
          break;
        case -5:
          xlog("L_WARN", "$ci|log|auth failed - code -5 no credentials - src ip: $si\n");
          break;
        case -6:
          xlog("L_WARN", "$ci|log|auth failed - code -6 nonce reused - src ip: $si\n");
          break;
        case -8:
          xlog("L_WARN", "$ci|log|auth failed - code -8 authuser mismatch - src ip: $si\n");
          break;
      }

      xlog("L_INFO", "$ci|log|Send auth challenge\n");

      # challenges for authentication by sending 401 for REGISTER and 407 for the other SIP requests
      auth_challenge("$fd", "1");
      xlog("L_INFO", "$ci|stop|----------------------------\n");
      exit;
    }

    setflag(FLAG_FROM_CUST);
    xlog("L_INFO", "$ci|log|User authenticated\n");
    # user authenticated - remove auth header

    if(!is_method("REGISTER|PUBLISH")){
      xlog("L_INFO", "$ci|log|User authenticated - not method REGISTER|PUBLISH\n");
      xlog("L_INFO", "$ci|log|User authenticated - remove auth header\n");
      xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
      $var(sipaccount) = $au;
      append_hf("X-PyFB-AccountId: $au\r\n");
      consume_credentials();
    }
  }


  # if caller is not local subscriber, then check if it calls
  # a local destination, otherwise deny, not an open relay here
  if (from_uri!=myself && uri!=myself) {
      xlog("L_INFO", "$ci|log| Message for another relay -> not allowed - END 403\n");
      xlog("L_INFO", "$ci|stop|----------------------------\n");
      sl_send_reply("403","Not relaying");
      exit;
  }

  xlog("L_INFO", "$ci|log| return \n");
  return;
}

#-------------

#-------------
#-------------
## 15_nat.cfg

# Caller NAT detection
route[NATDETECT] {
    xlog("L_INFO", "$ci|log|--start NATDETECT process--\n");
    force_rport();

    if (nat_uac_test("19")) {
        xlog("L_INFO", "$ci|log|----uac NAT test 19 true\n");

        if (is_method("REGISTER")) {
            xlog("L_INFO", "$ci|log|----Method REGISTER -> fix nat\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                xlog("L_INFO", "$ci|log|----First hop - set contact alias\n");
                set_contact_alias();
            }
        }

        xlog("L_INFO", "$ci|log|----Set flag NATS\n");
        setflag(FLT_NATS);
    }

    if (nat_uac_test("3")) {
        fix_nated_contact();
        xlog("L_INFO", "$ci|log|----Rewrites the Contact header to request source ip:port\n");
    }

#!endif
    xlog("L_INFO", "$ci|log| return \n");
    return;
}

route[NATMANAGE] {
    xlog("L_INFO", "$ci|log|--NATMANAGE--\n");

    if (is_request()) {
        if(has_totag()) {
            xlog("L_INFO", "$ci|log|----SIP Request - to-tag found--\n");
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
                xlog("L_INFO", "$ci|log|----SIP Request - route param nat=yes--\n");
            } else {
                xlog("L_INFO", "$ci|log|----SIP Request - no route param nat=yes--\n");
            }
        }
    }

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;


    if(has_body("application/sdp") && nat_uac_test("8")) {
        xlog("L_INFO", "$ci|log|----Fix nated sdp\n");
        fix_nated_sdp("10");
    }

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
                xlog("L_INFO", "$ci|log|----SIP Request - to-tag not found - Branch route--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
            }
        }
    }

    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            if(is_first_hop()) {
                set_contact_alias();
                xlog("L_INFO", "$ci|log|----SIP Reply - FLB_NATB set - First hop--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
            }
        }
    }

    xlog("L_INFO", "$ci|log|----Return \n");
    return;
}

#-------------

#-------------
#-------------
## 16_pstn.cfg

# PSTN GW routing
route[PSTN] {
    xlog("L_INFO", "$ci|log|--PSTN--\n");

    xlog("L_INFO", "$ci|log|--$fu--\n");

        route(RELAY);
        exit;
        return;
}

#-------------
## config/class5.cfg

# Determine originating internal servers routing blocks

# Test if call comes from C5 servers
route[C5INBOUND] {
    xlog("L_INFO", "$ci|log|--C5INBOUND route--");

    if(ds_is_from_list(GROUP_C5_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_C5);
        xlog("L_INFO", "$ci|log| Call from CLASS 5\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }

    xlog("L_INFO", "$ci|log| Message not coming from C5\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1;
}

# Test if call comes from SIPR servers
route[SIPRINBOUND] {
    xlog("L_INFO", "$ci|log|--SIPRINBOUND route--");

    if(ds_is_from_list(GROUP_SIPR_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_SIPR);
        xlog("L_INFO", "$ci|log| Call from SIPR\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }

    xlog("L_INFO", "$ci|log| Message not coming from SIPR\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1;
}

# Test if call comes from SBC servers
route[SBCINBOUND] {
    xlog("L_INFO", "$ci|log|--SBCINBOUND route--");

    if(ds_is_from_list(GROUP_SBC_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_SBC);
        xlog("L_INFO", "$ci|log| Call from SBC\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }

    xlog("L_INFO", "$ci|log| Message not coming from SBC\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1;
}

# Dispatch routes

route[DISPATCH] {
    xlog("L_INFO", "$ci|log|--DISPATCH route--\n");

    if(!is_method("INVITE")){
        xlog("L_INFO", "$ci|log| Not an INVITE\n");
        xlog("L_INFO", "$ci|log| return \n");
        return;
    }

    # Get callerID
    ## if PAI field
    # ONLY USED BY SBC ROLE
    if (is_present_hf("P-Asserted-Identity") && (isflagset(FLAG_FROM_PROV))) {
        # Only SBC accepts calls from provider
        xlog("L_INFO", "$ci|log| PAI detected");
        $avp(s:paicallernum)=$(hdr(P-Asserted-Identity){tobody.user});
        xlog("L_INFO", "$ci|log| Retrieved CallerId ($avp(s:paicallernum)) from P-Asserted-Identity header \r\n");
        xlog("L_INFO", "$ci|log| Remove PAI header \n");
        remove_hf("P-Asserted-Identity");
    }
    $avp(s:callernum)=$fU;

    # Call coming from carrier
    # ONLY USED BY SBC ROLE
    if(isflagset(FLAG_FROM_PROV)){
        # Only SBC accepts calls from provider
        xlog("L_INFO", "$ci|log| From carrier - inbound script starting ... \n");
        xlog("L_INFO", "$ci|log| Number normalization starting ... \n");
        if ($rU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log| Callee strip leading + \n");
            $rU=$(rU{s.strip,1});
        }
        if ($fU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log| Caller sip_network_ip leading + \n");
            $avp(s:callernum)=$(fU{s.strip,1});
        }

        xlog("L_INFO", "$ci|log| Route call to SIPR ... \n");

        # add Header to FS
        xlog("L_INFO", "$ci|log| Add headers\n");
        xlog("L_INFO", "$ci|log| X-AUTH-IP: $si\n");
        xlog("L_INFO", "$ci|log| X-AUTH-PORT: $sp\n");
        xlog("L_INFO", "$ci|log| X-Wazo-CallerNum: $avp(s:callernum)\n");
        append_hf("X-AUTH-IP: $si\r\n");
        append_hf("X-AUTH-PORT: $sp\r\n");
        append_hf("X-Wazo-DestNum: $rU\r\n");
        append_hf("X-Wazo-CallerNum: $avp(s:callernum)\r\n");

        # Relay call to SIPR only if dest i 112 or 18
/*
        # Note : dynamic version disabled for POC
        if (!dp_translate("0", "$rU/$avp(s:dest)")){
            xlog("L_WARNING", "$ci|log|Invalid Destination\n");
            send_reply("420", "Invalid Destination");
            exit;
        } else {
            xlog("L_INFO", "$ci|log|s:dest value : $avp(s:dest) \n");
        }
        # To Urgency number - mak as EMERGENCY
        if ($avp(s:dest)=="EMERGENCY") {
*/
        if ($rU=="112" || $rU=="18" || $rU=="0177513235")  {
            xlog("L_INFO", "$ci|log|Call type : EMERGENCY NUMBER \n");
            append_hf("X-PyFB-CallType: EMERGENCY\r\n");
            route(LBRELAY);
        } else {
            xlog("L_WARNING", "$ci|log| Call is not to 112 or 18 - END \n");
            send_reply("400", "Bad Request - Only 112|18 calls accepted");
            exit;
        }
    }

    # Call coming from SIPR - ONLY PSTN CALLS
    # ONLY FOR SBC ROLE
    if(isflagset(FLAG_FROM_SIPR)){
        xlog("L_INFO", "$ci|log|Message coming from SIPR : Routing outside - Call type : $hdr(X-PyFB-CallType)\n");
        if($hdr(X-PyFB-CallType) == "PSTN") {
            xlog("L_INFO", "$ci|log|Route to PSTN \n");
            route(PSTN);
        }
        remove_hf_re("^X-");
        xlog("L_INFO", "$ci|log| return \n");
        return;
    }

    # Call coming from C5
    # ONLY FOR SIPR ROLE
    if(isflagset(FLAG_FROM_C5)){
        xlog("L_INFO", "$ci|log|Message coming from C5 : Routing outside - Call type : $hdr(X-PyFB-CallType)\n");
        # test type of call
        if($hdr(X-PyFB-CallType) == "DIDOUT" || $hdr(X-PyFB-CallType) == "DIDIN") {
            xlog("L_INFO", "$ci|log|Route to corresponding user \n");
            route(LOCATION);
        } else {
            xlog("L_INFO", "$ci|log|Route to PSTN \n");
            append_hf("X-PyFB-CallType: PSTN\r\n");
            route(LBRELAY);
        }
        remove_hf_re("^X-");
        xlog("L_INFO", "$ci|log| return \n");
        return;
    }

}

route[LBRELAY] {
    xlog("L_INFO", "$ci|log|--LBRELAY--\n");

    # Choosing the right route and network interface to use

#!ifdef APP_SBC1
    # ONLY FOR SBC ROLE
    if(isflagset(FLAG_FROM_PROV)){
        # Call coming from provider to SIPR
        $avp(s:lbroute) = GROUP_SIPR_SERVERS;
        #ifdef MY_IP_ADDRESS_INTERNAL
          #force_send_socket(MY_IP_ADDRESS_INTERNAL);
        #endif
        xlog("L_INFO", "$ci|log| Route to SIPR pool : internal interface \n");
    }

    # ONLY FOR SBC ROLE
    if(isflagset(FLAG_FROM_SIPR)){
        # Call coming from SIPR to provider
        #ifdef MY_IP_ADDRESS_EXTERNAL
          #force_send_socket(MY_IP_ADDRESS_EXTERNAL);
        #endif
        xlog("L_INFO", "$ci|log| Route to provider pool : external interface \n");
        return;
    }
#!endif

#!ifdef APP_SIPR
    # ONLY FOR SIPR ROLE
    if(isflagset(FLAG_FROM_SBC)){
        # Call coming from SBC to C5
        $avp(s:lbroute) = GROUP_C5_SERVERS;
        #ifdef MY_IP_ADDRESS_INTERNAL
          #force_send_socket(MY_IP_ADDRESS_INTERNAL);
        #endif
        xlog("L_INFO", "$ci|log| Route to C5 pool : internal interface \n");
    }
#!endif

    # ONLY FOR FULL ROLE
    if(isflagset(FLAG_FROM_PROV)){
        # Call coming from PROV to C5
        $avp(s:lbroute) = GROUP_C5_SERVERS;
        #!ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket(ADDRESS_INTERNAL);
        #!endif
        xlog("L_INFO", "$ci|log| Route to C5 pool : internal interface \n");
    }

    # ONLY FOR FULL ROLE
    if(isflagset(FLAG_FROM_C5)){
        # Call coming from C5 to PROV
        $avp(s:lbroute) = GROUP_OP_SERVERS;
        #!ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket(ADDRESS_EXTERNAL);
          #record_route_advertised_address("ADVERTISED_ADDRESS");
        #endif
        xlog("L_INFO", "$ci|log| Route to provider pool : external interface \n");
    }

#!ifdef APP_SIPR
    # ONLY FOR SIPR ROLE
    if(isflagset(FLAG_FROM_C5)){
        # Call coming from C5 to SBC
        #$avp(s:lbroute) = GROUP_SBC_SERVERS;
        #ifdef MY_IP_ADDRESS_EXTERNAL
          #force_send_socket(MY_IP_ADDRESS_EXTERNAL);
        #endif
        xlog("L_INFO", "$ci|log| Route to SBC pool : external interface \n");
    }
#!endif

    # Load balancing process
    xlog("L_INFO", "$ci|log| Start load balancing process \n");
    if(!ds_select_dst($avp(s:lbroute), "4")) {
        xlog("L_WARNING", "$ci|log| No server available in pool - end \n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Service Unavailable");
        exit;
    }

    xlog("L_INFO", "$ci|log| List of servers available : $avp(AVP_DST)\n");
    xlog("L_INFO", "$ci|log| Server found : relay message to $du\n");

    if($var(newbranch)==1)
    {
        append_branch();
        $var(newbranch) = 0;
    }

    xlog("L_INFO", "$ci|log| return \n");
    t_set_fr(0,1000);
    t_on_failure("RTF_DISPATCH");
    route(RELAY);
    exit;
}

# Manage failure routing cases
failure_route[RTF_DISPATCH] {
    xlog("L_INFO", "$ci|log|--RTF DISPATCH--\n");
    if (t_is_canceled()) {
        exit;
    }

    # next DST - only for 500 or local timeout
    if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied())) {
        #we mark the destination Inactive and Probing
        ds_mark_dst("tp");
        #select the new destination
        if(ds_next_dst()) {
            t_set_fr(0,1000);
            xlog("L_INFO", "$ci|log| Send to next available server : relay message to $du\n");
            t_on_failure("RTF_DISPATCH");
            route(RELAY);
            exit;
        }
        else {
            #last available node failed to reply, no other destination available
            xlog("L_WARNING", "$ci|log| No more server available in pool : END\n");
            send_reply("404", "No destination");
            exit;
        }
    }
}

# Dispatcher detects a destination goes down
event_route[dispatcher:dst-down] {
    xlog("L_ERR", "DISPATCHER|log|C5 server down: $rm $ru ($du)\n");
}

# Dispatcher detects a destination comes up
event_route[dispatcher:dst-up] {
    xlog("L_ERR", "DISPATCHER|log|C5 server up: $rm $ru\n");
}
# FreeSWITCH routing blocks
route[FSINBOUND] {
  xlog("L_INFO", "$ci|log|--FSINBOUND--");
  if(ds_is_from_list()){
       remove_hf_re("^X-.*");
       setflag(FLAG_FROM_FS);
       xlog("L_INFO", "$ci|log|Call from FS\n");
       xlog("L_INFO", "$ci|log| return \n");
       return 1;
  }
  xlog("L_INFO", "$ci|log|Message not coming from FS\n");
  # à changer si call PSTN
  xlog("L_INFO", "$ci|log| return \n");
        return -1;
}

route[FSDISPATCH] {
    xlog("L_INFO", "$ci|log|--FSDISPATCH--\n");
        if(!is_method("INVITE")){
        xlog("L_INFO", "$ci|log|Not an INVITE\n");
        xlog("L_INFO", "$ci|log| return \n");
                return;
    }

    # Get callerID
    ## if PAI field
    if (is_present_hf("P-Asserted-Identity") && (!isflagset(FLAG_FROM_FS))) {
        xlog("L_INFO", "$ci|log| PAI detected");
        $avp(s:paicallernum)=$(hdr(P-Asserted-Identity){tobody.user});
        xlog("L_INFO", "$ci|log| Retrieved CallerId ($avp(s:paicallernum)) from P-Asserted-Identity header \r\n");
        xlog("L_INFO", "$ci|log| Remove PAI header \n");
        remove_hf("P-Asserted-Identity");
    }
    $avp(s:callernum)=$fU;

    #Call coming from provider
    if(isflagset(FLAG_FROM_PROV)){
        xlog("L_INFO", "$ci|log|From provider - inbound script starting ... \n");
        xlog("L_INFO", "$ci|log|Number normalization starting ... \n");
        if ($rU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log|Callee strip leading + \n");
            $rU=$(rU{s.strip,1});
        }
        if ($fU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log|Caller sip_network_ip leading + \n");
            $avp(s:callernum)=$(fU{s.strip,1});
        }

        xlog("L_INFO", "$ci|log|Call type mapping starting ... \n");
        # mark type of outbound calls
        # To internal DID - mark as DID
        route(LOCATION);
        # add Header to FS
        xlog("L_INFO", "$ci|log|Add headers for FS\n");
        xlog("L_INFO", "$ci|log|X-AUTH-IP: $si\n");
        xlog("L_INFO", "$ci|log|X-AUTH-PORT: $sp\n");
        xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
        xlog("L_INFO", "$ci|log|X-PyFB-CallerNum: $avp(s:callernum)\n");
        append_hf("X-AUTH-IP: $si\r\n");
        append_hf("X-AUTH-PORT: $sp\r\n");
        append_hf("X-PyFB-DestNum: $rU\r\n");
        append_hf("X-PyFB-CallerNum: $avp(s:callernum)\r\n");

        if ($avp(s:dest)=="DID") {
            xlog("L_INFO", "$ci|log|Call type : DIDIN NUMBER \n");
            append_hf("X-PyFB-CallType: DIDIN\r\n");
            route(FSRELAY);
        } else {
            if (!registered("location")){
                exit;
            }
        }
    }

    #Call coming from FS
        if(isflagset(FLAG_FROM_FS)){
        remove_hf("Remote-Party-ID");
        xlog("L_INFO", "$ci|log|Message coming from FS : Routing outside - Call type : $hdr(X-PyFB-CallType)\n");
        # test type of call
        if($hdr(X-PyFB-CallType) == "DIDOUT"||$hdr(X-PyFB-CallType) == "DIDIN") {
            xlog("L_INFO", "$ci|log|Route to corresponding user \n");
            route(LOCATION);
        } else {
            xlog("L_INFO", "$ci|log|Route to PSTN \n");
            route(PSTN);
        }
        remove_hf_re("^X-");
        xlog("L_INFO", "$ci|log| return \n");
                return;
  }

  # Call coming from customer
  if(isflagset(FLAG_FROM_CUST)){
    xlog("L_INFO", "$ci|log|From customer - outbound script starting ... \n");
    xlog("L_INFO", "$ci|log|Number normalization starting ... \n");
    if ($rU=~"^\+") {
      # strip leading +
      xlog("L_INFO", "$ci|log|Callee strip leading + \n");
      $rU=$(rU{s.strip,1});
    }
    if ($fU=~"^\+") {
      # strip leading +
      xlog("L_INFO", "$ci|log|Caller strip leading + \n");
      $avp(s:callernum)=$(fU{s.strip,1});
    }
    #dialplan
    append_hf("X-PyFB-CalleeNum: $rU\r\n");
    xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallee)")) {
      xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcallee)\n");
      xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
      if (!dp_translate("$avp(s:grpnormcallee)", "$rU/$rU")) {
        xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
      }
      xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
    } else {
      xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
    }
    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcaller)")) {
      xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcaller)\n");
      xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
      if (!dp_translate("$avp(s:grpnormcaller)", "$fU/$avp(s:callernum)")) {
        xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
        # $avp(s:callernum) = $fU;
        # uac_replace_from("sip:$avp(s:callernum)@$fd");
      }
      xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
    } else {
      xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
    }

    xlog("L_INFO", "$ci|log|Call type mapping starting ... \n");
    # mark type of outbound calls
    # To internal DID - mark as DID
    route(LOCATION);

    # add Header to FS
    xlog("L_INFO", "$ci|log|Add headers for FS\n");
    xlog("L_INFO", "$ci|log|X-AUTH-IP: $si\n");
    xlog("L_INFO", "$ci|log|X-AUTH-PORT: $sp\n");
    xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
    xlog("L_INFO", "$ci|log|X-PyFB-CallerNum: $avp(s:callernum)\n");
    append_hf("X-AUTH-IP: $si\r\n");
    append_hf("X-AUTH-PORT: $sp\r\n");
    append_hf("X-PyFB-DestNum: $rU\r\n");
    append_hf("X-PyFB-CallerNum: $avp(s:callernum)\r\n");

    if ($avp(s:dest)=="DID") {
      xlog("L_INFO", "$ci|log|Call type : DID NUMBER \n");
      append_hf("X-PyFB-CallType: DIDOUT\r\n");
      route(FSRELAY);
    }
    if (!dp_translate("0", "$rU/$avp(s:dest)")){
      xlog("L_INFO", "$ci|log|Invalid Destination\n");
      send_reply("420", "Invalid Destination");
      exit;
    } else {
      xlog("L_INFO", "$ci|log|s:dest value : $avp(s:dest) \n");
    }
    # To Urgency number - mak as EMERGENCY
    if ($avp(s:dest)=="EMERGENCY") {
      xlog("L_INFO", "$ci|log|Call type : EMERGENCY NUMBER \n");
      append_hf("X-PyFB-CallType: EMERGENCY\r\n");
      route(FSRELAY);
    }
    # To Own number - mark as OWN
    if ($avp(s:dest)=="OWN") {
      xlog("L_INFO", "$ci|log|Call type : OWN NUMBER \n");
      append_hf("X-PyFB-CallType: OWN\r\n");
      route(FSRELAY);
    }
    # Outbound call - mark as PSTN
    xlog("L_INFO", "$ci|log|Call type : PSTN NUMBER \n");
    append_hf("X-PyFB-CallType: PSTN\r\n");
    route(FSRELAY);
  }
  # ds_mark_dst("P");
  else {
    if (!registered("location")){
      exit;
    }
    route(FSRELAY);
  }
        #route(LOCATION);
}

route[FSRELAY] {
  xlog("L_INFO", "$ci|log|--FSRELAY--\n");

  # Call coming from provider
  if(isflagset(FLAG_FROM_PROV)){
      $avp(s:fsroute) = GROUP_SOFIA_EXT;
      #ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket("MY_IP_ADDRESS_EXTERNAL");
      #endif
      xlog("L_INFO", "$ci|log|Route to FS profile : externe - port 5092 \n");
  } else {
      $avp(s:fsroute) = GROUP_SOFIA_INT;
      #ifdef MY_IP_ADDRESS_INTERNAL
          force_send_socket("MY_IP_ADDRESS_INTERNAL");
      #endif
      xlog("L_INFO", "$ci|log|Route to FS profile : interne - port 5090 \n");
  }

  if(!ds_select_dst($avp(s:fsroute), "4")) {
    xlog("L_INFO", "$ci|log|No FS available - end \n");
    xlog("L_INFO", "$ci|stop|----------------------------\n");
    sl_send_reply("500", "Service Unavailable");
    exit;
  }
  xlog("L_INFO", "$ci|log|List of FS available : $avp(AVP_DST)\n");
  xlog("L_INFO", "$ci|log|FS server found : relay message to $du\n");
  if($var(newbranch)==1)
  {
          append_branch();
          $var(newbranch) = 0;
  }
  xlog("L_INFO", "$ci|log| return \n");
  t_set_fr(0,1000);
  t_on_failure("RTF_DISPATCH");
  route(RELAY);
  exit;
}

# Manage failure routing cases
failure_route[RTF_DISPATCH] {
  xlog("L_INFO", "$ci|log|--RTF DISPATCH--\n");
        if (t_is_canceled()) {
                exit;
        }
        # next DST - only for 500 or local timeout
        if (t_check_status("500")
                        or (t_branch_timeout() and !t_branch_replied()))
        {
                #we mark the destination Inactive and Probing
                ds_mark_dst("tp");
                #select the new destination
                if(ds_next_dst())
                {
                        t_set_fr(0,1000);
                        xlog("L_INFO", "$ci|log|Send to next FS server : relay message to $du\n");
                        t_on_failure("RTF_DISPATCH");
                        route(RELAY);
                        exit;
                }
                else
                {
                        #last available node failed to reply, no other destination available
                        xlog("L_INFO", "$ci|log|No more FS server available : END\n");
                        send_reply("404", "No destination");
                        exit;
                }
        }
}

# Dispatcher detects a destination goes down
event_route[dispatcher:dst-down] {
    xlog("L_ERR", "DISPATCHER|log|FS server down: $rm $ru ($du)\n");
}

# Dispatcher detects a destination comes up
event_route[dispatcher:dst-up] {
    xlog("L_ERR", "DISPATCHER|log|FS server up: $rm $ru\n");
}
