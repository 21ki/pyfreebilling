# PyFB v3.0 - file version : 2019-01-29 18:34:02

#-------------
#-------------
## 0_init.cfg

#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.2 - PyFreeBilling v3.0
# config file : v3.0
#
#-- AGPL License

#-------------

#-------------
#-------------
## 1_vars.cfg

#----------------------- Custom Defined Variables ----------------------------#
#-------------------------------------

#-- IP addresses settings

#!substdef "!MY_IP_ADDRESS!1.1.1.1!g"
#!substdef "!MY_IP_ADDRESS_INTERNAL!1.1.1.2!g"
#!substdef "!MY_IP_ADDRESS_EXTERNAL!1.1.1.3!g"

#-- Domain settings

#!substdef "!SIP_FROM_DOMAIN_NAT!sip:pinger@pyfb.org!g"
#!substdef "!SIP_DOMAIN_KEEPALIVE!sip:keepalive@pyfb.org!g"

#-- DB settings

# IMPORTANT : MUST BE PRESENT IN kamailio-local.cfg !

##!define DBURL "postgres://kamailiopyfb:password@127.0.0.1:5432/kamailiopyfb"

#-- Timer settings
#!substdef "!TIMER_INVITE_NOANSWER!10000!g"

#------------- SECURITY  ----------------------------------#

#!define UABLOCKED "friendly-scanner|sipcli|sundayddr|sip-scan|iWar|sipsak" ## L594
#!define IPBANEXPIRE 300 ## L403
##check pike param

##!define WITH_TLS


#------------- SIPCAPTURE  --------------------------------#

#!define SIPCAPTURL "sip:1.1.1.4:9060"
#!define SIPCAPT 0

#------------- Global Parameters --------------------------#

async_workers=8

#!define MULTIDOMAIN 0

#-- SIP HEADERS

server_signature = no
server_header = "Server: PyFB_v3"
user_agent_header = "X-PROXY: PyFB_v3"
sip_warning = 0


#------------ Others settings ------------------------------#
fork=yes
children=8
tcp_connection_lifetime=3605
tcp_accept_no_cl=yes
disable_tcp=no
enable_tls=false
tos=0x68

#------------- DNS settings -------------------------------#
use_dns_cache=on
dns_try_ipv6=no
dns_retr_time=1
dns_retr_no=3
dns_use_search_list=yes

#------------- Local settings -------------------------------#
include_file "kamailio-local.cfg"

#-------------

#-------------
#-------------
## 2_logging.cfg

#!ifdef WITH_DEBUG
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=4
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!else
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=2
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!endif

#-- syslog facility
log_facility=LOG_LOCAL0
log_name="kamailio"

#-------------

#-------------
#-------------
## 3_flags.cfg

#------------- FLAGS  -------------------------------------#

 #!define FLT_ACC 1
 #!define FLT_ACCMISSED 2
 #!define FLT_ACCFAILED 3
 #!define FLT_NATS 5
 #!define FLB_NATB 6
 #!define FLB_NATSIPPING 7
 #!define SIP_IP_OK 8
 #!define RINGING 10
 #!define CUST_AUTH_OK 11
 #!define RTPE 13
 #!define CANCELLED 14
 #!define ANSWERED 17

 #!define TRUSTED_ADR_GR_CUST 1
 # http://kamailio.org/docs/modules/4.4.x/modules/permissions.html#sec-registration-permissions
 #!define TRUSTED_ADR_GR_REG_CUST 2 # filtered to be implemented
 #!define TRUSTED_ADR_GR_GW 10
 #!define GROUP_GL_NORM_RULE 0

 #!define GROUP_OP_SERVERS 4

 flags
   FLAG_FROM_CUST: 10,
   FLAG_FROM_PROV: 11,
   FLAG_TRUSTED_SOURCE: 12;

#-------------

#-------------
#-------------
## 4_modules.cfg

#-------------------- Modules Section ----------------------------------------#

#-- modules directory

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#-- core modules

loadmodule "kex.so"
loadmodule "corex.so"

#-------- Loading Mod postgres ------------------------------------------------#

loadmodule "db_postgres.so"

#-------- Loading Mod TLS -----------------------------------------------------#

#!ifdef WITH_TLS
  enable_tls=yes
  loadmodule "tls.so"
  modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#-------- Loading Mod TM ------------------------------------------------------#

loadmodule "tm.so"
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", TIMER_INVITE_NOANSWER)
modparam("tm", "fr_inv_timer", 120000)

loadmodule "tmx.so"

#-------- Loading Mod SL ---------------------------------------------#

loadmodule "sl.so"

#-------- Loading Mod RR ---------------------------------------------#

loadmodule "rr.so"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_full_lr", 1)

#-------- Loading Mod PV ---------------------------------------------#
loadmodule "pv.so"
modparam("pv", "varset", "defaultChannels=i:2")
modparam("pv", "varset", "max_attempts=i:2")

#-------- Loading Mod AVPOPS -----------------------------------------#
loadmodule "avpops.so"
modparam("avpops", "db_url", DBURL)
modparam("avpops", "avp_table", "usr_preferences")

#-------- Loading Mod MAXFWD -----------------------------------------#
loadmodule "maxfwd.so"

#-------- Loading Mod USRLOC -----------------------------------------#
loadmodule "usrloc.so"
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "timer_interval", 20)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)

#-------- Loading Mod ALIASDB ----------------------------------------#
loadmodule "alias_db.so"
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)

#-------- Loading Mod REGISTRAR --------------------------------------#
## usrloc and sl module must be loaded before
loadmodule "registrar.so"
modparam("registrar", "method_filtering", 1)
modparam("registrar", "append_branches", 0)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod AUTH -----------------------------------------#
loadmodule "auth.so"
modparam("auth", "nonce_count", 1)
modparam("auth", "qop", "auth")
modparam("auth", "nonce_expire", 60)
modparam("auth", "nonce_auth_max_drift", 2)
modparam("auth", "auth_checks_register", 11)
modparam("auth", "auth_checks_no_dlg", 9)
modparam("auth", "auth_checks_in_dlg", 15)
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "version_table", 0)
loadmodule "permissions.so"
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(s:sipacid)")

#-------- Loading Mod DISPATCHER ------------------------------------#
/* loadmodule "dispatcher.so"
#modparam("dispatcher", "db_url", DBPYFBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 1)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_latency_estimator_alpha", 900)
modparam("dispatcher", "ds_ping_from", "sip:sipcheck@MY_IP_ADDRESS")
modparam("dispatcher", "ds_ping_method", "INFO")
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_probing_threshold", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=5;class=2;code=480;code=404;code=403;code=488;class=3") */

#-------- Loading Mod DIALPLAN ---------------------------------------#
loadmodule "dialplan.so"
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "attrs_pvar", "$avp(s:dest)")

#-------- Loading Mod JSON MODULES------------------------------#
loadmodule "jansson.so"
loadmodule "rtjson.so"


#-------- Loading Mod DIALOG ---------------------------------------#
/* loadmodule "dialog.so"
modparam("dialog", "db_url", DBURL)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_update_period", 45)
modparam("dialog", "profiles_with_value", "endptChannels;custChannels;didChannels;")
modparam("dialog", "dlg_flag", 4) */

#-------- Loading Mod NATHELPER ------------------------------------#
## usrloc module must be loaded before
loadmodule "nathelper.so"
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "SIP_FROM_DOMAIN_NAT")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod RTPENGINE  ------------------------------------#
loadmodule "rtpengine.so"
modparam("rtpengine", "rtpengine_sock", RTPENGINE_LIST)

#-------- Loading Mod IPOPS -----------------------------------------#
loadmodule "ipops.so"

#-------- Loading Mod UAC -------------------------------------------#
## tm, rr et dialog modules must be loaded before
loadmodule "uac.so"
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_retry_interval", 300)
modparam("uac", "reg_contact_addr", "MY_IP_ADDRESS_EXTERNAL:5060")

#-------- Loading Mod REDIS -----------------------------------------#
#loadmodule "ndb_redis.so"
#modparam("ndb_redis", "server", REDIS)

#-------- Loading Mod PIKE ------------------------------------------#
#!ifdef WITH_ANTIFLOOD
  loadmodule "pike.so"
  modparam("pike", "sampling_time_unit", 2)
  modparam("pike", "reqs_density_per_unit", 16)
  modparam("pike", "remove_latency", 4)
#!endif

#-------- Loading Mod XLOG XHTTP SIPUTILS AND SANITY  ---------------#
loadmodule "textops.so"
loadmodule "sdpops.so"
## sl module must be loaded before
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"

#-------- Loading Mod DEBUG -----------------------------------------#
#!ifdef WITH_DEBUG
  loadmodule "debugger.so"
  modparam("debugger", "cfgtrace", 1)
  modparam("debugger", "log_level_name", "exec")
#!endif

#-------- Loading Mod HASH TABLE -------------------------------------#
loadmodule "htable.so"
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

#------ Loading Mod ACC ----------------------------------------------#

loadmodule "acc.so"
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "cdr_enable", 0)
modparam("acc", "db_url", DBURL)
modparam("acc", "cdrs_table", "cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "db_table_missed_calls", "failed_sessions")
modparam("acc", "time_mode", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
#modparam("acc", "cdr_extra","attempt=$dlg_var(call_attempts);src_ip=$dlg_var(src_ip);calling_num=$dlg_var(caller_id);called_number=$dlg_var(called_number);sipCode=$dlg_var(sip_code);sipReason=$dlg_var(sip_reason)")
#modparam("acc", "db_extra","attempt=$dlg_var(call_attempts);src_ip=$dlg_var(src_ip);calling_num=$dlg_var(caller_id);called_number=$dlg_var(called_number);sipCode=$dlg_var(sip_code);sipReason=$dlg_var(sip_reason)")

#------ Loading Mod SIPTRACE -------------------------------------------#
#!ifdef WITH_SIPTRACE
    loadmodule "siptrace.so"
    modparam("siptrace", "duplicate_uri", SIPCAPTURL)
    modparam("siptrace", "hep_mode_on", 1)
    modparam("siptrace", "trace_to_database", 0)
    modparam("siptrace", "trace_flag", 2)
    modparam("siptrace", "hep_version", 1)
    modparam("siptrace", "trace_on", SIPCAPT)
#!endif

#-------------

#-------------
#-------------
## 5_request_route.cfg

#-- MAIN ROUTING SECTION
# -1- request route
# -2- req init
# -3- within dialog
# -4- relay
# -5- uri update for dialog request
# -6- manage branch
# -7- manage reply
# -8- manage failure
# -9- optionnaly block 3XX

request_route {

    # log the basic info regarding this call
    xlog("L_INFO", "$ci|start|\n");
    xlog("L_INFO", "$ci|log|===================================================\n");
    xlog("L_INFO", "$ci|log| New SIP message $rm with call-ID $ci \n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");
    xlog("L_INFO", "$ci|log| received $pr request $rm $ou\n");
    xlog("L_INFO", "$ci|log| source $si:$sp\n");
    xlog("L_INFO", "$ci|log| from $fu\n");
    xlog("L_INFO", "$ci|log| to $tu\n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");
    xlog("L_INFO", "$ci|log|---------------------------------------------------\n");

    # siptrace
    #!ifdef WITH_SIPTRACE
      sip_trace();
      setflag(22);
    #!endif

    # per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # OPTION processing
    if(is_method("OPTIONS") && uri==myself) {
        sl_send_reply("200","Keepalive");
        xlog("L_INFO", "$ci|log| Send SIP answer 200-OK - Keepalive\n");
        xlog("L_INFO", "$ci|stop|=================================================\n");
        exit;
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle retransmissions
    if(t_precheck_trans()) {
        t_check_trans();
        exit;
    }
    t_check_trans();

    # authentication
    route(AUTH);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
    }

    # handle presence related requests
    route(PRESENCE);

    # handle registrations
    #!ifdef WITH_REGISTRAR
      if (is_method("REGISTER")) {
          route(REGISTRAR);
      }
    #!endif

    if ($rU==$null) {
        # request with no Username in RURI
        xlog("L_INFO", "$ci|stop|-------SIP 484---------------\n");
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # save callee ID
    $avp(callee) = $rU;
    route(DISPATCH);

    route(RELAY);
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "$ci|log|--MANAGE_BRANCH--\n");
    xlog("L_INFO", "$ci|log|--new branch [$T_branch_idx] to $ru--\n");
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "$ci|log|--MANAGE_REPLY--\n");
    xlog("L_INFO", "$ci|log|--Handling SIP response--\n");
    xdbg("incoming reply\n");

    if(status=~"18[03]") {
        xlog("L_INFO", "$ci|log|--ringing or session in progress--\n");
    }
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }

  #!ifdef WITH_SIPTRACE
    sip_trace();
  #!endif
    if(nat_uac_test("18")) {
        #force_rport();
        #set_contact_alias();
        if (sdp_content()) {
            if(isflagset(FLAG_FROM_CUST)){
                xlog("L_INFO", "$ci|log|-- status [12]xxi from C5 - engage rtpengine--\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
            } else {
                xlog("L_INFO", "$ci|log|-- status [12]xx from outside - engage rtpengine--\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
            }
        }
    }
}


# Manage failure replies
failure_route[MANAGE_FAILURE] {
    xlog("L_INFO", "$ci|log|--MANAGE_FAILURE--\n");
    route(NATMANAGE);

    if (t_is_canceled()) exit;

  #!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
  #!endif
}

#-------------

#-------------
#-------------
## 6_relay.cfg

# Wrapper for relaying requests
route[RELAY] {

    xlog("L_INFO", "$ci|log|--RELAY--\n");
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }

    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(sdp_content()) {
            if(isflagset(FLAG_FROM_CUST)){
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
            }
        }
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }

    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        xlog("L_INFO", "$ci|end|unable to relay message\n");
        sl_reply_error();
    } else {
        xlog("L_INFO", "$ci|pass|successfull relay $du\n");
    }

    xlog("L_INFO", "$ci|stop|----------------------------\n");
    exit;
}

#-------------

#-------------
#-------------
## 7_reqinit.cfg

# Per SIP request initial checks
route[REQINIT] {
    xlog("L_INFO", "$ci|log|--REQINIT--\n");

  #!ifdef WITH_ANTIFLOOD
    xlog("L_INFO", "$ci|log|Antiflood protection\n");
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }

        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    if($ua =~ "friendly-scanner|sipcli|sundayddr") {
        xlog("L_WARN", "$ci|end|dropping message with user-agent $ua from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    xlog("L_INFO", "$ci|log|OK -> continue\n");
  #!endif

    if (is_method("INVITE|REGISTER")) {
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_WARN", "$ci|end|Someone from $si is doing an sql injection attack, blocking!\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    # initial sanity checks -- messages with
    # max_forwards==0, or excessively long requests
    if (!maxfwd_process("50") && $retcode==-1) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    # next hop is a gateway, so make no sense to
    # forward if MF is 0 (after decrement)
    if ( is_maxfwd_lt("5") ) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    /*if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }*/

    if(!sanity_check("1511", "7")) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    # CVE-2018-8828
    if($(ci{s.len}) + $(hdr(CSeq){s.len}) + $(ft{s.len}) + $(sel(v.branch){s.len}) >= 254) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp - header >=254\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }
    if($(rU{s.len}) > 32) {
        xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp - r-URI username > 32\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }
}

#-------------

#-------------
#-------------
## 8_withindlg.cfg

# Handle requests within SIP dialogs
route[WITHINDLG] {
    xlog("L_INFO", "$ci|log|--WITHINDLG--\n");

    if (!has_totag()) {
        xlog("L_INFO", "$ci|log| return\n");
        return;
    }

    if (is_method("REGISTER")) {
        xlog("L_INFO", "$ci|log| REGISTER method - return\n");
        return;
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        xlog("L_INFO", "$ci|log|loose route TRUE\n");
        route(DLGURI);

        if(is_method("INVITE|UPDATE") && sdp_content() && nat_uac_test("18")) {
            if (has_body("application/sdp")) {
                if(isflagset(FLAG_FROM_CUST)){
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=internal direction=external");
                } else {
                    rtpengine_manage("replace-origin replace-session-connection ICE=remove direction=external direction=internal");
                }
            }
        }

        if (is_method("BYE")) {
            xlog("L_INFO", "$ci|log|Method BYE - set acc flag\n");
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            xlog("L_INFO", "$ci|log|Method ACK\n");
            route(NATMANAGE);
        } else if ( is_method("INVITE|NOTIFY") ) {
            xlog("L_INFO", "$ci|log|Method INVITE|NOTIFY\n");
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }

        xlog("L_INFO", "$ci|log|Message has tag - no loose route -> relay\n");
        route(RELAY);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    if ( is_method("INVITE") ) {
        sl_send_reply("100","Your Re-INVITE is received");


        if (!t_relay()) {
            sl_reply_error();
            break;
        }

        # sl_send_reply("200","OK");
        exit;
    }


    xlog("L_INFO", "$ci|stop|----------------------------\n");
    sl_send_reply("404","Not here");
    exit;
}

#-------------

#-------------
#-------------
## 9_dlguri.cfg

# URI update for dialog requests
route[DLGURI] {
    xlog("L_INFO", "$ci|log|--DLGURI--\n");

    if(!isdsturiset()) {
        xlog("L_INFO", "$ci|log|--destination address URI (outbound proxy address) not set--\n");
        handle_ruri_alias();
        switch ($rc) {
        case -1:
            xlog("L_ERR", "$ci|log|--Failed to handle alias of R-URI $ru--\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            xlog("L_INFO", "$ci|log|--Alias param was found - Routing in-dialog $rm from $fu to $du--\n");
            break;
        case 2:
            xlog("L_INFO", "$ci|log|--Alias param was not found and nothing was done - Routing in-dialog $rm from $fu to $ru--\n");
            break;
        };
    }

    xlog("L_INFO", "$ci|log| return \n");
    return;
}

#-------------

#-------------
#-------------
## 10_registrar.cfg

# Handle SIP registrations
route[REGISTRAR] {
    xlog("L_INFO", "$ci|log|--REGISTRAR--\n");
    if (!is_method("REGISTER")) {
        xlog("L_INFO", "$ci|log|Not a REGISTER method\n");
        xlog("L_INFO", "$ci|log| return\n");
        return;
    }

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        #!ifdef WITH_NATSIPPING
           # do SIP NAT pinging
           setbflag(FLB_NATSIPPING);
        #!endif
    }

    xlog("L_INFO", "$ci|log|Save user in location DB\n");
    if (!save("location")) {
        sl_reply_error();
    }

    xlog("L_INFO", "$ci|stop|----------------------------\n");
    exit;
}

event_route[usrloc:contact-expired] {
  xlog("L_INFO", "expired contact for $ulc(exp=>aor)\n");
}

#-------------

#-------------
#-------------
## 11_location.cfg

# User location service
route[LOCATION] {
  xlog("L_INFO", "$ci|log|--LOCATION--\n");
  $var(DID) = $rU;

  # search in DB-based aliases
  xlog("L_INFO", "$ci|log|Check if DestNum is DID list \n");

  if(alias_db_lookup("dbaliases")) {
    xlog("L_INFO", "$ci|log|DID found in dbaliases.  R-URI=$ru\n");
    $avp(s:dest)="DID";
    append_hf("P-hint: DID routing\r\n");
  }
  else  {
    xlog("L_INFO", "$ci|log|R-URI=$ru  DID Not found in dbaliases\n");
    return;
  }

  xlog("L_INFO", "$ci|log|Check if corresponding user is registred\n");

  if (!lookup("location")) {
    $var(rc) = $rc;
    #route(TOVOICEMAIL);
    t_newtran();
    switch ($var(rc)) {
    case -1:
      xlog("L_INFO","$ci|log|R-URI=$ru - no contact found in location DB - continue \n");
      send_reply("480", "Temporarily Unavailable");
    case -3:
      xlog("L_INFO","$ci|log|R-URI=$ru - internal error when searching in location DB - 404 \n");
      send_reply("404", "Not Found");
      exit;
    case -2:
      xlog("L_INFO","$ci|log|R-URI=$ru - contacts found, but method not support in location DB - 405 \n");
      send_reply("405", "Method Not Allowed");
      exit;
    }
  } else {
    # User is registered. Overwrite the username part of the R-URI with the DID
    $rU = $var(DID);

    if($hdr(X-PyFB-CallType) == "DIDIN" || $hdr(X-PyFB-CallType) == "DIDOUT") {
      # Numbers normalization
      $var(sipaccount) = $hdr(X-PyFB-SIPAccountId);
      xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
      # Callee normalization
      if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcalleein)")) {
        xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcalleein)\n");
        xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
        if (!dp_translate("$avp(s:grpnormcalleein)", "$rU/$rU")) {
          xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
        }
        else {
          # To field is not auto updated - do it now
          uac_replace_to("sip:$rU@$rd");
        }

        xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
      } else {
        xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
      }

      # Caller normalization
      if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallerin)")) {
        xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcallerin)\n");
        xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
        if (!dp_translate("$avp(s:grpnormcallerin)", "$fU/$avp(s:callernum)")) {
          xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
        } else {
          uac_replace_from("$avp(s:callernum)", "sip:$avp(s:callernum)@$fd");
          remove_hf("P-Asserted-Identity");
          append_hf("P-Asserted-Identity: <sip:$avp(s:callernum)@$fd>\r\n");
        }
        xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
      } else {
        xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
      }
    }

    append_hf("X-PyFB-DestDIDNum: $var(DID)\r\n");
    xlog("L_INFO","$ci|log|R-URI=$ru  Location=$du - contact found in location DB - route to user \n");
    xlog("L_INFO","$ci|log| return \n");
    return;
  }

  # when routing via usrloc, log the missed calls also
  if (is_method("INVITE")) {
    setflag(FLT_ACCFAILED); # -- this is added to record failed calls
    setflag(FLT_ACCMISSED);
  }

  # via FS
  #route(RELAY);
        #exit;
}

#-------------

#-------------
#-------------
## 12_presence.cfg

# Presence server processing
route[PRESENCE] {
        xlog("L_INFO", "$ci|log|--PRESENCE--\n");
        if(!is_method("PUBLISH|SUBSCRIBE")) return;
        xlog("L_INFO", "$ci|log| Event: $hdr(Event)\n");

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                # returns here if no voicemail server is configured
                xlog("L_INFO", "$ci|stop| 404 - No voicemail service\n");
                sl_send_reply("404", "No voicemail service");
                exit;
        }

#!ifdef WITH_PRESENCE
        if (!t_newtran()) {
                sl_reply_error();
                exit;
        }

        if(is_method("PUBLISH")) {
                handle_publish();
                t_release();
        } else if(is_method("SUBSCRIBE")) {
                handle_subscribe();
                t_release();
        }
        exit;
#!endif

        # if presence enabled, this part will not be executed
        if(is_method("SUBSCRIBE") && $hdr(Event)=="presence.winfo") {
                xlog("L_INFO", "$ci|stop| 489 - No presence service\n");
                sl_send_reply("489", "No presence service");
                exit;
        }

        if (is_method("PUBLISH") || $rU==$null) {
                xlog("L_INFO", "$ci|stop| 404 - Not here\n");
                sl_send_reply("404", "Not here");
                exit;
        }
        xlog("L_INFO", "$ci|log| return \n");
        return;
}

#-------------

#-------------
#-------------
## 14_auth.cfg

# Authorization and authentication
# First determine the origini of the call based on IP address :
# 1- from customer
# 2- from provider IP Auth
# 3- From provider - regsitred gateway
# 4- from customer et REGISTER message
#
# The second step is to determine is the sip user is registred (Not for the POC)
route[AUTH] {
  xlog("L_INFO", "$ci|log|--AUTH-\n");
  xlog("L_INFO", "$ci|log| Starting auth process ...\n");

  # 1- message fom customer
  xlog("L_INFO", "$ci|log|IP Auth process ...\n");
  if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_CUST)) {
    setflag(FLAG_FROM_CUST);
    $var(sipaccount) = $avp(s:sipacid);
    append_hf("X-PyFB-AccountId: $avp(s:sipacid)\r\n");
    xlog("L_INFO", "$ci|log|Call from customer : Source IP allowed - sipaccount : $avp(s:sipacid)\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 2- message from provider
  if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_GW)) {
    setflag(FLAG_FROM_PROV);
    xlog("L_INFO", "$ci|log|Call from provider GW : Source IP allowed\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 3- message from a registred gateway
### A TERMINER
  if((!is_method("REGISTER")) && uac_reg_lookup("$rU", "$ru")) {
    setflag(FLAG_FROM_PROV);
    xlog("L_INFO", "$ci|log| request from a remote SIP provider [$rU => $tU]\n");
    ## si URI not DID : $tU in $rU
    $rU = $tU;
    xlog("L_INFO", "$ci|log| request from a remote SIP provider [$rU => $tU]\n");
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }

  # 4- check credential auth
  if (is_method("REGISTER") || uri==myself) {
    # authenticate requests
    if (!auth_check("$fd", "subscriber", "3")) {
      switch ($retcode) {
        case -1:
          xlog("L_WARN", "$ci|log|auth failed - code -1 generic error - src ip: $si\n");
          t_reply("403", "Forbidden");
          exit;
        case -2:
          xlog("L_WARN", "$ci|log|auth failed - code -2 invalid password - src ip: $si\n");
          t_reply("500", "Internal Server Error");
          exit;
        case -3:
          xlog("L_WARN", "$ci|log|auth failed - code -3 invalid user - src ip: $si\n");
          t_reply("400", "Bad Request");
          exit;
        case -4:
          xlog("L_WARN", "$ci|log|auth failed - code -4 nonce exprired - src ip: $si\n");
          break;
        case -5:
          xlog("L_WARN", "$ci|log|auth failed - code -5 no credentials - src ip: $si\n");
          break;
        case -6:
          xlog("L_WARN", "$ci|log|auth failed - code -6 nonce reused - src ip: $si\n");
          break;
        case -8:
          xlog("L_WARN", "$ci|log|auth failed - code -8 authuser mismatch - src ip: $si\n");
          break;
      }

      xlog("L_INFO", "$ci|log|Send auth challenge\n");

      # challenges for authentication by sending 401 for REGISTER and 407 for the other SIP requests
      auth_challenge("$fd", "1");
      xlog("L_INFO", "$ci|stop|----------------------------\n");
      exit;
    }

    setflag(FLAG_FROM_CUST);
    xlog("L_INFO", "$ci|log|User authenticated\n");
    # user authenticated - remove auth header

    if(!is_method("REGISTER|PUBLISH")){
      xlog("L_INFO", "$ci|log|User authenticated - not method REGISTER|PUBLISH\n");
      xlog("L_INFO", "$ci|log|User authenticated - remove auth header\n");
      xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
      $var(sipaccount) = $au;
      append_hf("X-PyFB-AccountId: $au\r\n");
      consume_credentials();
    }
  }


  # if caller is not local subscriber, then check if it calls
  # a local destination, otherwise deny, not an open relay here
  if (from_uri!=myself && uri!=myself) {
      xlog("L_INFO", "$ci|log| Message for another relay -> not allowed - END 403\n");
      xlog("L_INFO", "$ci|stop|----------------------------\n");
      sl_send_reply("403","Not relaying");
      exit;
  }

  xlog("L_INFO", "$ci|log| return \n");
  return;
}

#-------------

#-------------
#-------------
## 15_nat.cfg

# Caller NAT detection
route[NATDETECT] {
    xlog("L_INFO", "$ci|log|--start NATDETECT process--\n");
    force_rport();

    if (nat_uac_test("19")) {
        xlog("L_INFO", "$ci|log|----uac NAT test 19 true\n");

        if (is_method("REGISTER")) {
            xlog("L_INFO", "$ci|log|----Method REGISTER -> fix nat\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                xlog("L_INFO", "$ci|log|----First hop - set contact alias\n");
                set_contact_alias();
            }
        }

        xlog("L_INFO", "$ci|log|----Set flag NATS\n");
        setflag(FLT_NATS);
    }

    if (nat_uac_test("3")) {
        fix_nated_contact();
        xlog("L_INFO", "$ci|log|----Rewrites the Contact header to request source ip:port\n");
    }

#!endif
    xlog("L_INFO", "$ci|log| return \n");
    return;
}

route[NATMANAGE] {
    xlog("L_INFO", "$ci|log|--NATMANAGE--\n");

    if (is_request()) {
        if(has_totag()) {
            xlog("L_INFO", "$ci|log|----SIP Request - to-tag found--\n");
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
                xlog("L_INFO", "$ci|log|----SIP Request - route param nat=yes--\n");
            } else {
                xlog("L_INFO", "$ci|log|----SIP Request - no route param nat=yes--\n");
            }
        }
    }

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;


    if(has_body("application/sdp") && nat_uac_test("8")) {
        xlog("L_INFO", "$ci|log|----Fix nated sdp\n");
        fix_nated_sdp("10");
    }

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
                xlog("L_INFO", "$ci|log|----SIP Request - to-tag not found - Branch route--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
            }
        }
    }

    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            if(is_first_hop()) {
                set_contact_alias();
                xlog("L_INFO", "$ci|log|----SIP Reply - FLB_NATB set - First hop--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
            }
        }
    }

    xlog("L_INFO", "$ci|log|----Return \n");
    return;
}

#-------------

#-------------
#-------------
## 16_pstn.cfg

# PSTN GW routing
route[PSTN] {
    xlog("L_INFO", "$ci|log|--PSTN--\n");

    xlog("L_INFO", "$ci|log|--$fu--\n");

    /* $var(route_json) = "{
	"version": "1.0",
	"routing": "serial",
	"routes":
    [
		{
			"uri": "sip:127.0.0.1:5080",
			"dst_uri": "sip:127.0.0.1:5082",
			"path": "<sip:127.0.0.1:5084>, <sip:127.0.0.1:5086>",
			"socket": "udp:127.0.0.1:5060",
			"headers": {
				"from": {
					"display": "Alice",
					"uri": "sip:alice@127.0.0.1"
				},
				"to": {
					"display": "Alice",
					"uri": "sip:alice@127.0.0.1"
				},
				"extra": "X-Hdr-PyFB: abc\r\nX-Hdr-B: bcd\r\n"
			},
			"branch_flags": 8,
			"fr_timer": 5000,
			"fr_inv_timer": 30000
		  },
	  ]
   }"; */

        $ru = "sip:@1.1.1.1";
        route(RELAY);
        exit;
        return;
}

#-------------

#-------------
#-------------
## 17_normalization.cfg

route[REMOVEPLUS] {
  xlog("L_INFO", "$ci|log|--REMOVEPLUS--\n");

  if ($rU=~"^\+") {
    # strip leading +
    xlog("L_INFO", "$ci|log|Callee strip leading + \n");
    $rU=$(rU{s.strip,1});
  }
  if ($fU=~"^\+") {
    # strip leading +
    xlog("L_INFO", "$ci|log|Caller leading + \n");
    $avp(s:callernum)=$(fU{s.strip,1});
  }
}

route[REMOVEPAI] {
  xlog("L_INFO", "$ci|log|--REMOVEPAI--\n");

  if (is_present_hf("P-Asserted-Identity")) {
    xlog("L_INFO", "$ci|log| PAI detected");
    $avp(s:paicallernum)=$(hdr(P-Asserted-Identity){tobody.user});
    xlog("L_INFO", "$ci|log| Retrieved CallerId ($avp(s:paicallernum)) from P-Asserted-Identity header \r\n");
    xlog("L_INFO", "$ci|log| Remove PAI header \n");
    remove_hf("P-Asserted-Identity");
  }
  $avp(s:callernum)=$fU;
}

route[REMOVEPID] {
  xlog("L_INFO", "$ci|log|--REMOVEPID--\n");
}

route[NORMALIZATION] {
  xlog("L_INFO", "$ci|log|--NORMALIZATION--\n");

  # Get the value to check in usr_pref
  # If it is a call from customer, we check the value associated with sipaccount number
  if(isflagset(FLAG_FROM_CUST)){
    xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
    $avp(s:avp_norm_variable)=$var(sipaccount);
  }
  
  if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallee)")) {
    xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcallee)\n");
    xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
    if (!dp_translate("$avp(s:grpnormcallee)", "$rU/$rU")) {
      xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
    }
    xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
  } else {
    xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
  }
  if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcaller)")) {
    xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcaller)\n");
    xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
    if (!dp_translate("$avp(s:grpnormcaller)", "$fU/$avp(s:callernum)")) {
      xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
      # $avp(s:callernum) = $fU;
      # uac_replace_from("sip:$avp(s:callernum)@$fd");
    }
    xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
  } else {
    xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
  }
}


#-------------

#-------------
#-------------
## 18_rate.cfg

route[GETCUSTRATE] {
  xlog("L_INFO", "$ci|log|--GETCUSTRATE--\n");

  # table : pyfb_rating_cr_allocation
  # pyfb_rating_c_country_rate

}

route[GETPROVRATE] {
  xlog("L_INFO", "$ci|log|--GETPROVRATE--\n");

  # table : pyfb_routing_c_routinggrp => customer_id routinggroup_id
  # pyfb_rating_p_prefix_rate avec une PRIO à 1 ...

}

#-------------

#-------------
#-------------
## 19_direction.cfg

route[DIRECTIONMAPPING] {
  xlog("L_INFO", "$ci|log|--DIRECTIONMAPPING--\n");

 #table : pyfb_direction

  # CallerID

  # CallerId

}

#-------------
